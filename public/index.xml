<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Siete3.com</title>
    <link>http://www.siete3.com/</link>
    <description>Recent content on Siete3.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 01 Jan 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://www.siete3.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>programming functors</title>
      <link>http://www.siete3.com/posts/functional/functors/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.siete3.com/posts/functional/functors/</guid>
      <description>#Functors
 Functor is simply an interface with a contract. We could have just as easily named it Mappable, but now, where&amp;rsquo;s the fun in that?. Professor Frisby&amp;rsquo;s 
A functor is nothing more than a data structure that you can map functions with the purpose of lifting values intro a wrapper, modifying them, and then putting them back into a wrapper.
It is a design pattern that defines semantics for how fmap should work</description>
    </item>
    
    <item>
      <title>Testing prototype inheritance</title>
      <link>http://www.siete3.com/posts/patterns/testing-protoype-inheritance/</link>
      <pubDate>Wed, 21 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.siete3.com/posts/patterns/testing-protoype-inheritance/</guid>
      <description>https://stackoverflow.com/questions/53406070/using-call-to-inherit-objects-from-a-function
// testing Call to inherit objects / functions // ------------------------------------------- // we declare our first function const funcA = function(firstName) { this.firstName = firstName; this.getFirstName = function() { return &#39;My name is &#39; + this.firstName; }; return this; }; // Create an object out of that function const objA = new funcA(&#39;Rodrigo&#39;); // declare second function const funcB = function (lastName) { this.lastName = lastName; this.getLastName = function() { return &#39;My last name is &#39; + this.</description>
    </item>
    
    <item>
      <title>Mixins</title>
      <link>http://www.siete3.com/posts/patterns/mixins/</link>
      <pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.siete3.com/posts/patterns/mixins/</guid>
      <description>In JavaScript we can only inherit from a single object. There can be only one [[Prototype]] for an object. And a class may extend only one other class.
To solve the use of multi inheritance we use mixins.
In object-oriented programming languages, a Mixin is a class that contains methods for use by other classes without having to be the parent class of those other classes.
A mixin can also be viewed as an interface with implemented methods.</description>
    </item>
    
    <item>
      <title>Global variables are bad</title>
      <link>http://www.siete3.com/posts/global-variables-are-bad/</link>
      <pubDate>Thu, 14 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.siete3.com/posts/global-variables-are-bad/</guid>
      <description>Extracted from a Gist, a very nice explanation // It is important to declare your variables. (function() { var foo = &#39;Hello, world!&#39;; print(foo); //=&amp;gt; Hello, world! })(); print(foo); // No way José !! // Because if you don&#39;t, the become global variables. (function() { foo = &#39;Hello, world!&#39;; print(foo) //=&amp;gt; Hello, world! })(); print(foo) //=&amp;gt; WTF, it returns &amp;quot;Hello, world!&amp;quot; // When global variables sneak into your code they can cause problems.</description>
    </item>
    
    <item>
      <title>statement branching Vs micro-branching</title>
      <link>http://www.siete3.com/posts/statement-branching-vs-micro-branching/</link>
      <pubDate>Wed, 06 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.siete3.com/posts/statement-branching-vs-micro-branching/</guid>
      <description>statement branching Any construct that alters the sequence of statement execution within the global or functional scope. These include:
if else switch for while  Statements are designed to execute non-linearly. Aside from the obvious bloating effect, statement branching tends to become unintuitive as it progresses.
micro-branching Conditional logic contained within a statement that has no effect on the statement execution seqeunce.
The following operators facilitate micro-branching:  ternary (&amp;lt;cond&amp;gt; ?</description>
    </item>
    
    <item>
      <title>IIFE - Iimmediatelly Invoked Function Expression</title>
      <link>http://www.siete3.com/posts/patterns/iife/</link>
      <pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.siete3.com/posts/patterns/iife/</guid>
      <description>IIFE - Iimmediatelly Invoked Function Expression var foo = &amp;quot;foo1&amp;quot;; (function() { var foo = &amp;quot;foo2&amp;quot;; console.log(foo); // foo2 })(); console.log(foo); // foo1 // we can also write the above statement like: (function() { // code }());  We use IIFE in order to not pollute the global scope.
Bibliography: Ben Alman: Immediately-Invoked Function Expression (IIFE)</description>
    </item>
    
    <item>
      <title>Lexical and Dynamic scope</title>
      <link>http://www.siete3.com/posts/lexical-and-dynamic-scope/</link>
      <pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.siete3.com/posts/lexical-and-dynamic-scope/</guid>
      <description>Lexical scoping Evil eval We can cheat on lexical scoping using eval keywod. The eval keyword, takes any given strings and it treats as it was a code
var bar = &amp;quot;foo&amp;quot;; function foo(str) { eval(str); console.log(&amp;quot;bar&amp;quot;); // 42 !!!!! } foo(&amp;quot;var bar = 42&amp;quot;);  The problem of doing this is that performance will be afected because as we know JS first assign the LHS (left hand side), witch means that it will read all the assigments on the left and lator will do the right hand side of the code.</description>
    </item>
    
    <item>
      <title>functional programming</title>
      <link>http://www.siete3.com/posts/functional/functional-programming/</link>
      <pubDate>Fri, 12 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.siete3.com/posts/functional/functional-programming/</guid>
      <description>functional programming In computer science, functional programming is a programming paradigm — a style of building the structure and elements of computer programs— that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.
It is a declarative programming paradigm, which means programming is done with expressions or declarations instead of statements. To put it in a diferent way we can say that declarative programming cares about what to perform an action and imperative cares about how to perform that action</description>
    </item>
    
    <item>
      <title>Method chaining in Javascript</title>
      <link>http://www.siete3.com/posts/method-chaining-in-javascript/</link>
      <pubDate>Mon, 08 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.siete3.com/posts/method-chaining-in-javascript/</guid>
      <description>Method chaining in Javascript from wikipedia Method chaining, also known as named parameter idiom, is a common syntax for invoking multiple method calls in object-oriented programming languages.
The key to achieve this is that each method returns an object, allowing the calls to be chained together in a single statement without requiring variables to store the intermediate results.
A similar syntax is method cascading, where after the method call the expression evaluates to the current object, not the return value of the method.</description>
    </item>
    
  </channel>
</rss>